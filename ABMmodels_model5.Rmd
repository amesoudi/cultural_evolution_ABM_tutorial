---
title: "Simulation Models of Cultural Evolution"
author: "Alex Mesoudi"
---

### Model 5: Migration

Along with selection, mutation and drift, another fundamental driver of genetic evolution is migration. The same is true of cultural evolution. Migration has been a permanent fixture of our species since we first dispersed out of Africa. The movement of people from group to group can shape between-group cultural diversity, and spread beneficial technologies or ideas from group to group. 

In Model 5 we will examine the effect of migration on between-group diversity. Previous models all featured a single group of agents. Now that we are interested in migration, we need to simulate multiple groups. Let's keep things simple and add one other group, making two in total: group 1 and group 2. As before, each group has $N$ individuals in it.

As before, let's assume that there are two traits, $A$ and $B$. We'll assume for now that they are neutral, i.e. not subject to selection / biased transmission. We assume that, initially, every member of group 1 has $A$, and every member of group 2 has $B$. Hence, in generation 1, $p = 1$, and $q = 0$, where $p$ denotes the frequency of trait $A$ in group $1$ and $q$ denotes the frequency of trait $A$ in group 2. Such a case of maximum group difference might seem extreme, but is not too far from a situation where everyone in one society speaks one language and everyone in another society speaks another language, or everyone in one group practices one religion and everyone in another practices a different religion. In any case, remember that models are simplified, extreme cases designed to check the logic of verbal arguments, not exact recreations of reality.

The following code creates two agent dataframes, one for each group, and populates them with agents according to starting frequencies $p_0 = 1$ and $q_0 = 0$. Unlike before, we create another column recording which group this is, 1 or 2. We then combine the two dataframes into a single one using the **rbind** command, which combines dataframes by rows. Finally, we check it worked by calling the first five agents in group 1, i.e. agents one to five, who should all have trait $A$, and the first five agents in group 2, i.e. agents $N+1$ to $N+5$, who should all have trait $B$.

```{r}

N <- 100
p_0 <- 1
q_0 <- 0

agent1 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(p_0,1-p_0)), group = 1, stringsAsFactors = FALSE)  # create first generation of group 1

agent2 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(q_0,1-q_0)), group = 2, stringsAsFactors = FALSE)  # create first generation of group 2

agent <- rbind(agent1,agent2)  # combine agent1 and agent2 into a single agent dataframe

agent[1:5,]
agent[(N+1):(N+5),]

```

We can also calculate the frequency of $A$ in groups 1 and 2, or $p$ and $q$, and check that $p = 1$ and $q = 0$, with this code:

```{r}

p <- sum(agent$trait[agent$group == 1] == "A") / N
q <- sum(agent$trait[agent$group == 2] == "A") / N

paste("p =", p)
paste("q =", q)

```

This code uses subsetting to get the number of $A$s in group 1, and then in group 2, and divides both by $N$ to get a proportion.

Now for migration. In each timestep, we assume that each agent has a probability $m$ of migrating. There is a problem, though. Because this is stochastic, this might result in the groups changing size. Maybe in one generation five agents move from group 1 to group 2, while only two move from group 2 to group 1. Then, group 1 would be smaller than group 2, and neither would be $N$. This gets complicated to model, as the size of the dataframes holding agents would need to change during the simulations.

To avoid $N$ from changing during the simulation, we can do the following, drawing inspiration from what's known as Wright's Island Model from population genetics. First we pick $m$ agents across the entire population (ignoring group membership) to migrate. We take these migrants out of their groups, leaving empty slots where they used to be. Then we put these migrants back into the empty slots at random, ignoring which group the slot is in. This keeps $N$ constant: for every empty slot, there is a migrating agent. Some might go back into their original group, but this won't change anything so it doesn't really matter. 

Finally, we are assuming that agents take their traits with them, for now. We will change this later.

The following code simulates one bout of migration, i.e. one generation in the model.

```{r}

m <- 0.1

probs <- runif(1:(2*N))  # 2N probabilities, one for each agent, to compare against m

migrants <- agent$trait[probs < m]  # with prob m, add an agent's trait to list of migrants

agent$trait[probs < m] <- sample(migrants, length(migrants))  # put migrants randomly into empty slots

p <- sum(agent$trait[agent$group == 1] == "A") / N
q <- sum(agent$trait[agent$group == 2] == "A") / N

paste("p =", p)
paste("q =", q)

```

You should see here that $p$ has decreased slightly to be less than 1, and $q$ has increased slightly to be greater than 0. Migration seems to be bringing the frequencies closer together.

The following function simply repeats the above over $t_{max}$ generations and plots $p$ and $q$, all within a single function, similar to previous models. Note the new **legend** command, which allows us to label the two lines in the plot. 

```{r}

Migration <- function (N, p_0, q_0, m, t_max) {
  
  output <- data.frame(p = rep(NA, t_max), q = rep(NA, t_max)) # create output dataframe to hold t_max values of p and q
  
  agent1 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(p_0,1-p_0)), group = 1, stringsAsFactors = FALSE)  # create first generation of group 1

  agent2 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(q_0,1-q_0)), group = 2, stringsAsFactors = FALSE)  # create first generation of group 2

  agent <- rbind(agent1,agent2)  # combine agent1 and agent2 into a single agent dataframe
  
  # store first generation frequencies
  output$p[1] <- sum(agent$trait[agent$group == 1] == "A") / N
  output$q[1] <- sum(agent$trait[agent$group == 2] == "A") / N

  for (t in 2:t_max) {
  
    # migration
    probs <- runif(1:(2*N))  # 2N probabilities, one for each agent, to compare against m

    migrants <- agent$trait[probs < m]  # with prob m, add an agent's trait to list of migrants

    agent$trait[probs < m] <- sample(migrants, length(migrants))  # put migrants randomly into empty slots
    
    # store frequencies in output slot t
    output$p[t] <- sum(agent$trait[agent$group == 1] == "A") / N
    output$q[t] <- sum(agent$trait[agent$group == 2] == "A") / N

  }
  
  plot(x = 1:nrow(output), y = output$p, type = 'l', col = "orange", ylab = "proportion of agents with trait A", xlab = "generation", ylim = c(0,1), main = paste("N = ", N, ", m = ", m, sep = ""))
  lines(x = 1:nrow(output), y = output$q, col = "blue")
  legend("topright", legend = c("p (group 1)", "q (group 2)"), lty = 1, col = c("orange", "blue"), bty = "n")
  
  output  # export data from function
}
    
```

Now we can run the function with a reasonably strong migration rate of $m=0.1$:

```{r}

data_model5 <- Migration(N = 10000, p_0 = 1, q_0 = 0, m = 0.1, t_max = 100)

```

Migration causes both groups to converge on a 50:50 split of $A$ and $B$, i.e. $p=q=0.5$. Two groups that are initially entirely different in their cultural traits become identical (barring small random fluctuations). Even very small amounts of migration eventually yield between-group homogeneity:

```{r}

data_model5 <- Migration(N = 10000, p_0 = 1, q_0 = 0, m = 0.01, t_max = 1000)

```
Changing the starting frequencies reveals that $p$ and $q$ do not always converge on 0.5. Rather, they converge on the average initial frequency of $A$ across both groups (i.e. $(p_0+q_0) / 2$, which in the case below is 0.3):

```{r}

data_model5 <- Migration(N = 10000, p_0 = 0.1, q_0 = 0.5, m = 0.1, t_max = 100)

```

This consequence of migration, to break down between-group differences and make each group identical, is well known from population genetics. In order to maintain between-group variation in the face of even small amounts of migration, we therefore need some additional process.

In genetic evolution one such process is natural selection, if selection favours different alleles in different groups. This might happen, for example, if the groups inhabit different environments. In Models 3 and 4 we saw how directly biased transmission and conformist transmission can act as forms of cultural selection. Perhaps, then, these processes can maintain between-group variation in cultural evolution.

The following function adds directly biased transmission using code from the **BiasedTransmission** function of Model 3. We assume that trait $A$ is favoured in group 1, and trait $B$ is favoured in group 2. The parameter $s$ determines the strength of this biased transmission / cultural selection, which we assume is equal in strength (but opposite in direction) in each group. For simplicity we'll omit the multiple runs, hence no $r_max$.

```{r}

MigrationPlusBiasedTransmission <- function (N, p_0, q_0, m, s, t_max) {
  
  output <- data.frame(p = rep(NA, t_max), q = rep(NA, t_max)) # create output dataframe to hold t_max values of p and q
  
  agent1 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(p_0,1-p_0)), group = 1, stringsAsFactors = FALSE)  # create first generation of group 1

  agent2 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(q_0,1-q_0)), group = 2, stringsAsFactors = FALSE)  # create first generation of group 2

  agent <- rbind(agent1,agent2)  # combine agent1 and agent2 into a single agent dataframe
  
  # store first generation frequencies
  output$p[1] <- sum(agent$trait[agent$group == 1] == "A") / N
  output$q[1] <- sum(agent$trait[agent$group == 2] == "A") / N

  for (t in 2:t_max) {
  
    # migration
    probs <- runif(1:(2*N))  # 2N probabilities, one for each agent, to compare against m

    migrants <- agent$trait[probs < m]  # with prob m, add an agent's trait to list of migrants

    agent$trait[probs < m] <- sample(migrants, length(migrants))  # put migrants randomly into empty slots
    
    # biased transmission
    copy <- runif(2*N)  # get 2N random numbers, one per agent, each between 0 and 1
    
    # group 1 favours A
    demonstrator_trait <- sample(agent$trait[agent$group == 1], N, replace = TRUE)  # for each group 1 agent, pick a random agent to act as demonstrator and store their trait
    agent$trait[agent$group == 1 & demonstrator_trait == "A" & copy < s] <- "A"  # if demonstrator has A and with probability s, copy A from demonstrator
    
    # group 2 favours B
    demonstrator_trait <- sample(agent$trait[agent$group == 2], N, replace = TRUE)  # for each group 1 agent, pick a random agent to act as demonstrator and store their trait
    agent$trait[agent$group == 2 & demonstrator_trait == "B" & copy < s] <- "B"  # if demonstrator has B and with probability s, copy B from demonstrator
    
    # store frequencies in output slot t
    output$p[t] <- sum(agent$trait[agent$group == 1] == "A") / N
    output$q[t] <- sum(agent$trait[agent$group == 2] == "A") / N

  }
  
  plot(x = 1:nrow(output), y = output$p, type = 'l', col = "orange", ylab = "proportion of agents with trait A", xlab = "generation", ylim = c(0,1), main = paste("N = ", N, ", m = ", m, ", s = ", s, sep = ""))
  lines(x = 1:nrow(output), y = output$q, col = "blue")
  legend("topright", legend = c("p (group 1)", "q (group 2)"), lty = 1, col = c("orange", "blue"), bty = "n")
  
  output  # export data from function
}
    
```

And we run the function with $s=0.1$:

```{r}

data_model5 <- MigrationPlusBiasedTransmission(N = 10000, p_0 = 1, q_0 = 0, m = 0.1, s = 0.1, t_max = 100)

```

Here we can see how adding cultural selection in the form of directly biased transmission maintains some degree of between-group cultural variation. Group 1 has around 70% $A$ and 30% $B$, while group 2 has around 30% $A$ and 70% $B$. You can play around with different values of $s$ and $m$ to see how the frequencies change in response. When $s$ is large relative to $m$, then the groups maintain more distinctive cultural profiles.

Finally, we can see how conformist cultural transmission can also act to maintain between-group cultural variation in the face of migration. The following function integrates the original Migration model above with the ConformistTransmission function from Model 4. Note that conformity operates *within* each group, on the assumption that individuals are interacting only with other members of their own group, and never with members of the other group.

```{r}

MigrationPlusConformity <- function (N, p_0, q_0, m, D, t_max) {
  
  output <- data.frame(p = rep(NA, t_max), q = rep(NA, t_max)) # create output dataframe to hold t_max values of p and q
  
  agent1 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(p_0,1-p_0)), group = 1, stringsAsFactors = FALSE)  # create first generation of group 1

  agent2 <- data.frame(trait = sample(c("A","B"), N, replace = TRUE, prob = c(q_0,1-q_0)), group = 2, stringsAsFactors = FALSE)  # create first generation of group 2

  agent <- rbind(agent1,agent2)  # combine agent1 and agent2 into a single agent dataframe
  
  # store first generation frequencies
  output$p[1] <- sum(agent$trait[agent$group == 1] == "A") / N
  output$q[1] <- sum(agent$trait[agent$group == 2] == "A") / N

  for (t in 2:t_max) {
  
    # migration
    probs <- runif(1:(2*N))  # 2N probabilities, one for each agent, to compare against m

    migrants <- agent$trait[probs < m]  # with prob m, add an agent's trait to list of migrants

    agent$trait[probs < m] <- sample(migrants, length(migrants))  # put migrants randomly into empty slots
    
    # conformity in group 1:
    
    # create dataframe with a set of 3 randomly-picked group 1 demonstrators for each agent
    demonstrators <- data.frame(dem1 = sample(agent$trait[agent$group == 1], N, replace = TRUE), dem2 = sample(agent$trait[agent$group == 1], N, replace = TRUE), dem3 = sample(agent$trait[agent$group == 1], N, replace = TRUE), stringsAsFactors = F)

    # get the number of As in each 3-dem combo
    numAs <- rowSums(demonstrators == "A")

    agent$trait[agent$group == 1 & numAs == 3] <- "A"  # for dem combos with all As, set to A
    agent$trait[agent$group == 1 & numAs == 0] <- "B"  # for dem combos with no As, set to B

    prob <- runif(N)
      
    # when A is a majority, 2/3
    agent$trait[agent$group == 1 & numAs == 2 & prob < (2/3 + D/3)] <- "A"
    agent$trait[agent$group == 1 & numAs == 2 & prob >= (2/3 + D/3)] <- "B"

    # when A is a minority, 1/3
    agent$trait[agent$group == 1 & numAs == 1 & prob < (1/3 - D/3)] <- "A"
    agent$trait[agent$group == 1 & numAs == 1 & prob >= (1/3 - D/3)] <- "B"
    
    # conformity in group 2:
    
    # create dataframe with a set of 3 randomly-picked group 1 demonstrators for each agent
    demonstrators <- data.frame(dem1 = sample(agent$trait[agent$group == 2], N, replace = TRUE), dem2 = sample(agent$trait[agent$group == 2], N, replace = TRUE), dem3 = sample(agent$trait[agent$group == 2], N, replace = TRUE), stringsAsFactors = F)

    # get the number of As in each 3-dem combo
    numAs <- rowSums(demonstrators == "A")

    agent$trait[agent$group == 2 & numAs == 3] <- "A"  # for dem combos with all As, set to A
    agent$trait[agent$group == 2 & numAs == 0] <- "B"  # for dem combos with no As, set to B

    prob <- runif(N)
      
    # when A is a majority, 2/3
    agent$trait[agent$group == 2 & numAs == 2 & prob < (2/3 + D/3)] <- "A"
    agent$trait[agent$group == 2 & numAs == 2 & prob >= (2/3 + D/3)] <- "B"

    # when A is a minority, 1/3
    agent$trait[agent$group == 2 & numAs == 1 & prob < (1/3 - D/3)] <- "A"
    agent$trait[agent$group == 2 & numAs == 1 & prob >= (1/3 - D/3)] <- "B"
    
    # store frequencies in output slot t
    output$p[t] <- sum(agent$trait[agent$group == 1] == "A") / N
    output$q[t] <- sum(agent$trait[agent$group == 2] == "A") / N

  }
  
  plot(x = 1:nrow(output), y = output$p, type = 'l', col = "orange", ylab = "proportion of agents with trait A", xlab = "generation", ylim = c(0,1), main = paste("N = ", N, ", m = ", m, ", D = ", D, sep = ""))
  lines(x = 1:nrow(output), y = output$q, col = "blue")
  legend("topright", legend = c("p (group 1)", "q (group 2)"), lty = 1, col = c("orange", "blue"), bty = "n")
  
  output  # export data from function
}
    
```

With a moderate amount of conformity, $D=0.2$, i.e. a 20% chance of adopting the majority trait:

```{r}

data_model5 <- MigrationPlusConformity(N = 10000, p_0 = 1, q_0 = 0, m = 0.05, D = 0.2, t_max = 1000)

```

Here again, conformist transmission - a form of cultural selection - maintains between-group cultural variation even in the face of migration.

***

### Summary of Model 5

Model 5 looked at how migration across group boundaries can break down between-group cultural variation to create a homogenous, undifferentiated mass culture where every group is culturally identical. While globalisation via the mass media or global markets has perhaps been making real-life human societies more similar to one another in recent years, we can still discern culturally distinct societies across the world, marked by traits such as dress, language, religion, psychological characteristics, cuisine and so on. Prior to the invention of mass transit and mass communication, societies would have been even more distinct. Yet migration has been a constant fixture of our species since we dispersed out of Africa. How then can we reconcile the extensive between-group cultural variation of our species with this frequent migration?

We modelled two potential answers to this question, both forms of cultural selection. Where different traits are favoured in different groups, then directly biased transmission can maintain between-group cultural variation even in the face of migration. Similarly, conformity can maintain between-group cultural variation by causing migrants to adopt the majority trait in their new society. The latter works even for neutral, arbitrary traits, which may describe well many real-life group markers. Given that psychological processes such as conformity are unique to cultural evolution, this may also be an explanation for why there is a lot more between-group cultural variation in our species than there is between-group genetic variation (for further details and data on migration, conformity and between-group cultural variation, see Henrich & Boyd 1998; Bell, Richerson & McElreath 2009; and Mesoudi 2018).

The major programming innovation in Model 5 was the introduction of two groups of agents. This allows us to simulate migration between groups, as well as processes that are likely to occur predominantly within groups such as conformity. There are many ways of extending Model 5, including adding more groups, adding non-random migration, using measures like $F_{ST}$ to quantify the amount of between-group cultural variation, making the cultural traits cooperative / non-cooperative rather than neutral, and modelling other processes that might maintain variation such as punishment (see Mesoudi 2018).

***

### Analytic Appendix

TBA

## References

Bell, A. V., Richerson, P. J., & McElreath, R. (2009). Culture rather than genes provides greater scope for the evolution of large-scale human prosociality. Proceedings of the National Academy of Sciences, 106(42), 17671-17674.

Henrich, J., & Boyd, R. (1998). The evolution of conformist transmission and the emergence of between-group differences. Evolution and Human Behavior, 19(4), 215-241.

Mesoudi, A. (2018). Migration, acculturation, and the maintenance of between-group cultural variation. PlOS ONE, 13(10), e0205573.
